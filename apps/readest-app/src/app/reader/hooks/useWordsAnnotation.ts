import { useCallback, useEffect, useRef } from 'react';
import { FoliateView } from '@/types/view';
import { useReaderStore } from '@/store/readerStore';
import { getAnnotationProvider, WordAnnotation, ProperNounAnnotation, MWEAnnotation, TokenUsage } from '@/services/annotationLLMs';
import { walkTextNodes } from '@/utils/walk';
import { debounce } from '@/utils/debounce';

interface UseWordsAnnotationOptions {
  provider?: string;
  enabled?: boolean;
  retryAttempts?: number;
  retryDelay?: number;
}

export function useWordsAnnotation(
  bookKey: string,
  view: FoliateView | HTMLElement | null,
  options: UseWordsAnnotationOptions = {}
) {
  const {
    provider = 'qwen', 
    enabled = true,
    retryAttempts = 3,
    retryDelay = 1000
  } = options;

  const { getViewSettings, getViewState, getProgress } = useReaderStore();
  const viewSettings = getViewSettings(bookKey);
  const viewState = getViewState(bookKey);
  const progress = getProgress(bookKey);

  const enabledRef = useRef(enabled && viewSettings?.wordAnnotationEnabled);
  
  const observerRef = useRef<IntersectionObserver | null>(null);
  const annotatedElements = useRef<HTMLElement[]>([]);
  const allTextNodes = useRef<HTMLElement[]>([]);
  const processingQueue = useRef<Set<HTMLElement>>(new Set());
  
  // Êñ∞Â¢ûÔºöÁä∂ÊÄÅÊõ¥Êñ∞ÂõûË∞ÉÁÆ°ÁêÜ
  const statusUpdateCallbacksRef = useRef<Set<() => void>>(new Set());

  // Êñ∞Â¢ûÔºöÊ≥®ÂÜåÁä∂ÊÄÅÊõ¥Êñ∞ÂõûË∞ÉÂáΩÊï∞
  const registerStatusUpdateCallback = useCallback((callback: () => void) => {
    statusUpdateCallbacksRef.current.add(callback);
    
    // ËøîÂõûÂèñÊ∂àÊ≥®ÂÜåÁöÑÂáΩÊï∞
    return () => {
      statusUpdateCallbacksRef.current.delete(callback);
    };
  }, []);

  // Êñ∞Â¢ûÔºöËß¶ÂèëÁä∂ÊÄÅÊõ¥Êñ∞ÂõûË∞É
  const triggerStatusUpdate = useCallback(() => {
    console.log('üìå Triggering annotation status update callbacks');
    statusUpdateCallbacksRef.current.forEach(callback => {
      try {
        callback();
      } catch (error) {
        console.error('Error in status update callback:', error);
      }
    });
  }, []);

  // ÂàáÊç¢Ê≥®ÈáäÂèØËßÅÊÄßÔºàÁ±ª‰ººtranslationÁöÑtoggleTranslationVisibilityÔºâ
  const toggleAnnotationVisibility = useCallback((visible: boolean) => {
    annotatedElements.current.forEach((element) => {
      const annotationTargets = element.querySelectorAll('ruby.word');
      annotationTargets.forEach((target) => {
        if (visible) {
          target.classList.remove('hidden');
        } else {
          target.classList.add('hidden');
        }
      });
    });
  }, []);

  // ËßÇÂØüÊñáÊú¨ËäÇÁÇπÔºàÁ±ª‰ººtranslationÁöÑobserveTextNodesÔºâ
  const observeTextNodes = useCallback(() => {
    if (!view || !enabledRef.current) return;
    
    const observer = createAnnotationObserver();
    observerRef.current = observer;
    const nodes = walkTextNodes(view);
    console.log('Observing text nodes for annotation:', nodes.length);
    allTextNodes.current = nodes;
    nodes.forEach((el) => observer.observe(el));
  }, [view]);

  // Êõ¥Êñ∞Ê≥®ÈáäÔºàÁ±ª‰ººtranslationÁöÑupdateTranslationÔºâ
  const updateAnnotation = useCallback(() => {
    annotatedElements.current.forEach((element) => {
      // ÁßªÈô§Â∑≤ÊúâÁöÑrubyÊ†áÁ≠æ
      const rubyElements = element.querySelectorAll('ruby.word');
      rubyElements.forEach((ruby) => {
        const textContent = ruby.textContent || '';
        ruby.replaceWith(document.createTextNode(textContent));
      });
      
      // ÊÅ¢Â§çÂéüÂßãÊñáÊú¨
      if (element.hasAttribute('original-text-stored')) {
        const originalTexts = JSON.parse(element.getAttribute('original-text-nodes') || '[]');
        const textNodes = Array.from(element.childNodes).filter(
          (node) => node.nodeType === Node.TEXT_NODE
        ) as Text[];
        
        textNodes.forEach((textNode, index) => {
          if (originalTexts[index] !== undefined) {
            textNode.textContent = originalTexts[index];
          }
        });
        element.removeAttribute('original-text-stored');
        element.removeAttribute('original-text-nodes');
      }
      
      // Ê∏ÖÁêÜÊ≥®ÈáäÁõ∏ÂÖ≥ÁöÑÁ±ªÂêçÂíåÂ±ûÊÄß
      element.classList.remove('annotated', 'processing-annotation');
      element.removeAttribute('word-annotation-mark');
    });

    annotatedElements.current = [];
    if (viewSettings?.wordAnnotationEnabled && view) {
      recreateAnnotationObserver();
    }
  }, [viewSettings?.wordAnnotationEnabled, view]);

  // ÂàõÂª∫Ê≥®ÈáäËßÇÂØüÂô®ÔºàÁ±ª‰ººtranslationÁöÑcreateTranslationObserverÔºâ
  const createAnnotationObserver = useCallback(() => {
    return new IntersectionObserver(
      (entries) => {
        let beforeIntersectedElement: HTMLElement | null = null;
        let lastIntersectedElement: HTMLElement | null = null;
        
        for (const entry of entries) {
          if (!entry.isIntersecting) {
            if (!lastIntersectedElement) {
              beforeIntersectedElement = entry.target as HTMLElement;
            }
            continue;
          }
          
          const currentElement = entry.target as HTMLElement;
          annotateElement(currentElement);
          lastIntersectedElement = currentElement;
        }
        
        if (beforeIntersectedElement) {
          annotateElement(beforeIntersectedElement);
        }
        
        if (lastIntersectedElement) {
          preAnnotateNextElements(lastIntersectedElement, 2);
        }
      },
      {
        rootMargin: '1280px',
        threshold: 0,
      }
    );
  }, []);

  // È¢ÑÊ≥®Èáä‰∏ã‰∏ÄÊâπÂÖÉÁ¥†ÔºàÁ±ª‰ººtranslationÁöÑpreTranslateNextElementsÔºâ
  const preAnnotateNextElements = useCallback((currentElement: HTMLElement, count: number) => {
    if (!allTextNodes.current || count <= 0) return;
    
    const currentIndex = allTextNodes.current.indexOf(currentElement);
    if (currentIndex === -1) return;

    const nextElements = allTextNodes.current.slice(currentIndex + 1, currentIndex + 1 + count);
    nextElements.forEach((element, index) => {
      setTimeout(() => {
        annotateElement(element);
      }, index * 300); // ÊØîÁøªËØëÁ®çÂø´‰∏Ä‰∫õ
    });
  }, []);

  // ÈáçÊñ∞ÂàõÂª∫Ê≥®ÈáäËßÇÂØüÂô®ÔºàÁ±ª‰ººtranslationÁöÑrecreateTranslationObserverÔºâ
  const recreateAnnotationObserver = useCallback(() => {
    const observer = createAnnotationObserver();
    observerRef.current?.disconnect();
    observerRef.current = observer;
    allTextNodes.current.forEach((el) => observer.observe(el));
  }, [createAnnotationObserver]);

  // Ê£ÄÊü•ÂÖÉÁ¥†ÊòØÂê¶Â∑≤Ë¢´Ê≥®Èáä
  const isElementAnnotated = useCallback((element: HTMLElement): boolean => {
    return element.hasAttribute('word-annotation-mark') || 
           element.querySelectorAll('ruby.word').length > 0 ||
           element.classList.contains('annotated') ||
           element.classList.contains('processing-annotation');
  }, []);

  // ÊñáÊú¨ token ÂåñÂáΩÊï∞ - ÁÆÄÂåñÁâàÊú¨ÔºöÂçïËØçÂíåÁ¨¶Âè∑ÂàÜÂà´‰Ωú‰∏∫token
  const tokenizeText = useCallback((text: string): string[] => {
    // È¶ñÂÖàÂ§ÑÁêÜÊç¢Ë°åÁ¨¶ÈóÆÈ¢òÔºöÂ∞Ü\nÊõøÊç¢‰∏∫Á©∫Ê†ºÔºåÈÅøÂÖçÂçïËØçË¢´ÈîôËØØÂêàÂπ∂
    const normalizedText = text.replace(/\n/g, ' ');
    
    const tokens: string[] = [];
    const regex = /(\s+)|(\w+|[^\w\s])/g;
    let match;
    
    while ((match = regex.exec(normalizedText)) !== null) {
      if (match[1]) {
        tokens.push(match[1]); // Á©∫ÁôΩÂ≠óÁ¨¶
      } else if (match[2]) {
        tokens.push(match[2]); // ÂçïËØçÊàñÁ¨¶Âè∑
      }
    }
    
    return tokens;
  }, []);

  // ÂàõÂª∫Âçï‰∏™ÂçïËØçÁöÑrubyÊ†áÁ≠æ
  const createSingleWordRuby = useCallback((word: string, annotation: WordAnnotation, index: number): string => {
    return `<ruby class="word" lemma="${annotation.lemma}" data-word-index="${index}">${word}<rt class="zh-meaning">${annotation.zh}</rt><rt class="en-meaning">${annotation.en}</rt></ruby>`;
  }, []);

  // Ê†áÂáÜÂåñÊñáÊú¨ÂáΩÊï∞ÔºåÂ§ÑÁêÜ‰∏≠Ëã±ÊñáÂºïÂè∑Á≠âÂ≠óÁ¨¶Â∑ÆÂºÇ
  const normalizeText = useCallback((text: string): string => {
    return text
      .toLowerCase()
      // Áªü‰∏ÄÂêÑÁßçÂºïÂè∑
      .replace(/[''`]/g, "'")      // Â∞Ü‰∏≠ÊñáÂçïÂºïÂè∑„ÄÅÂèçÂºïÂè∑Áªü‰∏Ä‰∏∫Ëã±ÊñáÂçïÂºïÂè∑
      .replace(/[""]/g, '"')       // Â∞Ü‰∏≠ÊñáÂèåÂºïÂè∑Áªü‰∏Ä‰∏∫Ëã±ÊñáÂèåÂºïÂè∑
      // Áªü‰∏ÄÂêÑÁßçËøûÂ≠óÁ¨¶ÂíåÁü≠Ê®™Á∫ø
      .replace(/[‚Äî‚Äì‚àí]/g, '-')      // Â∞ÜÈïøÁü≠Ê®™Á∫øÁªü‰∏Ä‰∏∫ËøûÂ≠óÁ¨¶
      // Áªü‰∏ÄÁúÅÁï•Âè∑
      .replace(/‚Ä¶/g, '...')
      // ÂéªÈô§Èõ∂ÂÆΩÂ≠óÁ¨¶
      .replace(/[\u200B-\u200D\uFEFF]/g, '');
  }, []);

  // È°∫Â∫èÂåπÈÖçÂçïËØçÁöÑÂáΩÊï∞ - Êñ∞ÁâàÊú¨Ôºö‰ªéÂâçÂæÄÂêéÈ°∫Â∫èÂåπÈÖçÔºåËøûÁª≠3Ê¨°Â§±Ë¥•ÂêéË∑≥Ëøá
  const createOrderedWordRubyAnnotations = useCallback((text: string, annotations: { words: WordAnnotation[] }): string => {
    const tokens = tokenizeText(text);
    const llmWords = annotations.words;
    
    const resultTokens = [...tokens];
    let llmIndex = 0;
    let tokenIndex = 0;
    let wordIndex = 0;
    let totalMatched = 0;
    let consecutiveFailures = 0;
    const MAX_CONSECUTIVE_FAILURES = 3;

    const processedRanges: Set<number> = new Set();

    while (llmIndex < llmWords.length && tokenIndex < tokens.length) {
      const currentWord = llmWords[llmIndex];
      if (!currentWord) {
        llmIndex++;
        continue;
      }

      let found = false;
      let currentFailureStartToken = tokenIndex; // ËÆ∞ÂΩïÊú¨Ê¨°ÂçïËØçÂºÄÂßãÊêúÁ¥¢ÁöÑ‰ΩçÁΩÆ

      // ‰ªéÂΩìÂâç‰ΩçÁΩÆÂºÄÂßãÂêëÂâçÊêúÁ¥¢Ôºå‰ΩÜÈôêÂà∂ÊêúÁ¥¢ËåÉÂõ¥
      const maxSearchDistance = 10; // ÊúÄÂ§öÂêëÂâçÊêúÁ¥¢10‰∏™token
      const searchEnd = Math.min(tokenIndex + maxSearchDistance, tokens.length);

      for (let searchIndex = tokenIndex; searchIndex < searchEnd; searchIndex++) {
        if (processedRanges.has(searchIndex)) {
          continue;
        }

        const token = tokens[searchIndex];
        if (!token || /^\s+$/.test(token)) {
          continue;
        }
        
        const tokenLower = normalizeText(token);
        const wordLower = normalizeText(currentWord.word);

        // 1. ÂçïtokenÂåπÈÖç
        if (tokenLower === wordLower) {
          resultTokens[searchIndex] = createSingleWordRuby(token, currentWord, wordIndex);
          processedRanges.add(searchIndex);
          wordIndex++;
          totalMatched++;
          tokenIndex = searchIndex + 1;
          consecutiveFailures = 0; // ÈáçÁΩÆËøûÁª≠Â§±Ë¥•ËÆ°Êï∞
          found = true;
          break;
        }

        // 2. Ë∑®tokenÂêàÂπ∂ÂåπÈÖç (2-4‰∏™token) - Âè™ÂåπÈÖçÁúüÊ≠£ÈúÄË¶ÅÂêàÂπ∂ÁöÑÊÉÖÂÜµ
        for (let combineLength = 2; combineLength <= Math.min(4, searchEnd - searchIndex); combineLength++) {
          const endIndex = searchIndex + combineLength;
          
          // Ê£ÄÊü•ÁªÑÂêàËåÉÂõ¥ÂÜÖÁöÑtokenÊòØÂê¶Â∑≤Ë¢´Â§ÑÁêÜ
          let hasProcessedToken = false;
          for (let i = searchIndex; i < endIndex; i++) {
            if (processedRanges.has(i)) {
              hasProcessedToken = true;
              break;
            }
          }
          
          if (hasProcessedToken) {
            continue;
          }

          // ÊèêÂèñÂπ∂ÂêàÂπ∂token
          const combineTokens = tokens.slice(searchIndex, endIndex);
          const combinedText = normalizeText(combineTokens.join(''));
          const combinedDisplay = combineTokens.join('');

          // ÂÖ≥ÈîÆ‰øÆÂ§çÔºö‰∏•Ê†ºÊ£ÄÊü•Ëøô‰∏™ÁªÑÂêàÊòØÂê¶ÁúüÁöÑÊúâÊÑè‰πâ
          // 1. Â¶ÇÊûúÁªÑÂêàÂêéÁöÑÊñáÊú¨ÂåÖÂê´Á©∫Ê†ºÔºå‰∏îLLMÂçïËØç‰∏çÂåÖÂê´Á©∫Ê†ºÔºåÂàôË∑≥Ëøá
          const hasSpaceInCombined = combinedDisplay.includes(' ');
          const hasSpaceInWord = currentWord.word.includes(' ');
          
          if (hasSpaceInCombined && !hasSpaceInWord) {
            continue;
          }

          // 2. Ê£ÄÊü•ÊòØÂê¶ÂåÖÂê´Â§ö‰∏™ÂçïËØçtokenÔºàÈùûÊ†áÁÇπÁ¨¶Âè∑„ÄÅÈùûÁ©∫Ê†ºÔºâ
          const wordTokensInCombine = combineTokens.filter(t => t && !/^\s+$/.test(t) && /\w/.test(t));
          if (wordTokensInCombine.length > 1 && !hasSpaceInWord) {
            continue;
          }

          if (combinedText === wordLower) {
            // ÂàõÂª∫Ë∑®tokenÁöÑrubyÊ†áÁ≠æ - ‰ΩÜË¶ÅÁ°Æ‰øùÂêàÁêÜÊÄß
            const multiTokenRuby = createSingleWordRuby(combinedDisplay, currentWord, wordIndex);
            
            // Âè™Âú®Á¨¨‰∏Ä‰∏™tokenÂ§ÑÂàõÂª∫rubyÊ†áÁ≠æÔºåÂÖ∂‰ªñtoken‰øùÊåÅÂéüÊ†∑‰ΩÜÊ†áËÆ∞‰∏∫Â∑≤Â§ÑÁêÜ
            resultTokens[searchIndex] = multiTokenRuby;
            for (let i = searchIndex + 1; i < endIndex; i++) {
              // ‰øùÊåÅÂéüÂßãtokenÔºå‰ΩÜÊ†áËÆ∞‰∏∫Â∑≤Â§ÑÁêÜÔºàËøôÊ†∑‰∏ç‰ºöÂΩ±ÂìçÂÖ∂‰ªñÂåπÈÖçÔºâ
              processedRanges.add(i);
            }
            
            processedRanges.add(searchIndex);
            wordIndex++;
            totalMatched++;
            tokenIndex = endIndex;
            consecutiveFailures = 0; // ÈáçÁΩÆËøûÁª≠Â§±Ë¥•ËÆ°Êï∞
            found = true;
            break;
          }
        }

        if (found) break;
      }

      if (!found) {
        consecutiveFailures++;
        
        if (consecutiveFailures >= MAX_CONSECUTIVE_FAILURES) {
          llmIndex++; // Ë∑≥ËøáËøô‰∏™LLMÂçïËØç
          consecutiveFailures = 0; // ÈáçÁΩÆËÆ°Êï∞
          // tokenIndex‰øùÊåÅ‰∏çÂèòÔºå‰ªéÂΩìÂâç‰ΩçÁΩÆÂºÄÂßãÂåπÈÖç‰∏ã‰∏Ä‰∏™ÂçïËØç
        } else {
          // Ê≤°ÊúâËææÂà∞ÊúÄÂ§ßÂ§±Ë¥•Ê¨°Êï∞ÔºåÁªßÁª≠ÂêëÂâçÁßªÂä®tokenÊåáÈíà
          tokenIndex = currentFailureStartToken + 1;
          
          // Ë∑≥ËøáÁ©∫ÁôΩtoken
          while (tokenIndex < tokens.length && tokens[tokenIndex] && /^\s+$/.test(tokens[tokenIndex]!)) {
            tokenIndex++;
          }
          
          if (tokenIndex >= tokens.length) {
            llmIndex++;
            consecutiveFailures = 0;
          }
        }
      } else {
        llmIndex++;
      }
    }

    console.log(`üéØ Word matching completed: ${totalMatched}/${llmWords.length} words matched (${((totalMatched / llmWords.length) * 100).toFixed(1)}%)`);
    
    return resultTokens.join('');
  }, [tokenizeText, createSingleWordRuby, normalizeText]);

  // ‰ªéHTML‰∏≠ÊèêÂèñrubyÂçïËØçÊï∞ÁªÑÔºàÂü∫‰∫éÁ¥¢ÂºïÔºâ
  const extractRubyWordsArray = useCallback((htmlText: string): string[] => {
    // ÂÆâÂÖ®Ê£ÄÊü•
    if (!htmlText || typeof htmlText !== 'string') {
      return [];
    }
    
    // È¶ñÂÖàÊ£ÄÊü•ÊòØÂê¶ÂåÖÂê´rubyÊ†áÁ≠æ
    const hasRubyTags = htmlText.includes('<ruby');
    if (!hasRubyTags) {
      return [];
    }
    
    // Ê£ÄÊü•ÊòØÂê¶ÂåÖÂê´data-word-indexÂ±ûÊÄß
    const hasWordIndex = htmlText.includes('data-word-index');
    if (!hasWordIndex) {
      return [];
    }
    
    const rubyWords: string[] = [];
    const rubyPattern = /<ruby[^>]*data-word-index="(\d+)"[^>]*>(.*?)<\/ruby>/gs;
    let match;
    let matchCount = 0;
    
    try {
      while ((match = rubyPattern.exec(htmlText)) !== null) {
        const wordIndex = parseInt(match[1]!, 10);
        const rubyContent = match[2]!;
        
        // ÊèêÂèñrubyÊ†áÁ≠æÂÜÖÁöÑ‰∏ªË¶ÅÂçïËØçÂÜÖÂÆπÔºàÂéªÊéârtÊ†áÁ≠æÔºâ
        const wordText = rubyContent.replace(/<rt[^>]*>.*?<\/rt>/gs, '').trim();
        
        // Á°Æ‰øùÊï∞ÁªÑÂ§ßÂ∞èË∂≥Â§ü
        while (rubyWords.length <= wordIndex) {
          rubyWords.push('');
        }
        
        rubyWords[wordIndex] = wordText.toLowerCase();
        matchCount++;
      }
    } catch (error) {
      console.error('‚ùå Error during regex matching:', error);
      return [];
    }
    
    console.log(`üîç Extracted ${matchCount} ruby words for phrase matching`);
    
    return rubyWords;
  }, []);

  // Âü∫‰∫éÁ¥¢ÂºïÂåπÈÖçËØçÁªÑÂíå‰∏ìÊúâÂêçËØç
  const matchPhraseWithIndexes = useCallback((rubyWords: string[], targetPhrase: string): { startIndex: number, endIndex: number } | null => {
    const phraseWords = targetPhrase.toLowerCase().split(/\s+/).filter(w => w.length > 0);
    if (phraseWords.length === 0) return null;
    
    let bestMatch: { startIndex: number, endIndex: number, matchedCount: number } | null = null;
    
    // Âú®rubyÂçïËØçÊï∞ÁªÑ‰∏≠ÂØªÊâæÂåπÈÖç
    for (let searchStart = 0; searchStart < rubyWords.length; searchStart++) {
      const startWord = rubyWords[searchStart];
      
      // Ë∑≥ËøáÁ©∫Â≠óÁ¨¶‰∏≤
      if (!startWord || startWord.length === 0) {
        continue;
      }
      
      // Ê£ÄÊü•ÊòØÂê¶ÂåπÈÖçÁ¨¨‰∏Ä‰∏™ËØçÁªÑÂçïËØç
      if (startWord === phraseWords[0]) {
        // Â∞ùËØïÂåπÈÖçÂÆåÊï¥ËØçÁªÑ
        const matchedWords: number[] = [searchStart];
        let currentPhraseIndex = 1;
        let currentSearchIndex = searchStart + 1;
        let skippedNonEmpty = 0; // Ë∑≥ËøáÁöÑÈùûÁ©∫ÂçïËØçËÆ°Êï∞
        
        while (currentPhraseIndex < phraseWords.length && currentSearchIndex < rubyWords.length) {
          const targetWord = phraseWords[currentPhraseIndex]!;
          const searchWord = rubyWords[currentSearchIndex];
          
          if (!searchWord || searchWord.length === 0) {
            // Ë∑≥ËøáÁ©∫‰ΩçÁΩÆ
            currentSearchIndex++;
            continue;
          }
          
          if (searchWord === targetWord) {
            matchedWords.push(currentSearchIndex);
            currentPhraseIndex++;
            currentSearchIndex++;
            skippedNonEmpty = 0; // ÈáçÁΩÆË∑≥ËøáËÆ°Êï∞
          } else {
            // ‰∏çÂåπÈÖçÔºåË∑≥ËøáËøô‰∏™ÂçïËØç
            currentSearchIndex++;
            skippedNonEmpty++;
            
            // Â¶ÇÊûúË∑≥ËøáÂ§™Â§ö‰∏çÂåπÈÖçÁöÑÂçïËØçÔºåÊîæÂºÉËøôÊ¨°Â∞ùËØï
            if (skippedNonEmpty > 3) {
              break;
            }
          }
        }
        
        // Ê£ÄÊü•ÊòØÂê¶ÂÆåÂÖ®ÂåπÈÖç
        if (currentPhraseIndex === phraseWords.length) {
          const startIndex = matchedWords[0]!;
          const endIndex = matchedWords[matchedWords.length - 1]!;
          return { startIndex, endIndex };
        } else {
          // ËÆ°ÁÆóÂåπÈÖçÂ∫¶
          const matchRatio = currentPhraseIndex / phraseWords.length;
          
          // Â¶ÇÊûúÂåπÈÖçÂ∫¶ËææÂà∞70%‰∏îËá≥Â∞ëÂåπÈÖç‰∫Ü2‰∏™ÂçïËØçÔºåËÆ∞ÂΩï‰∏∫ÂÄôÈÄâ
          if (matchRatio >= 0.7 && currentPhraseIndex >= 2 && matchedWords.length >= 2) {
            const startIndex = matchedWords[0]!;
            const endIndex = matchedWords[matchedWords.length - 1]!;
            
            if (!bestMatch || currentPhraseIndex > bestMatch.matchedCount) {
              bestMatch = { startIndex, endIndex, matchedCount: currentPhraseIndex };
            }
          }
        }
      }
      
      // Â¶ÇÊûúÂΩìÂâçËØçÊ≤°ÊúâÂåπÈÖçÁ¨¨‰∏Ä‰∏™ËØçÁªÑÂçïËØçÔºå‰ΩÜÊàë‰ª¨Ê≠£Âú®ÂØªÊâæÂêéÁª≠ÂçïËØçÔºàÈÉ®ÂàÜÂåπÈÖçÁ≠ñÁï•Ôºâ
      for (let phraseIndex = 1; phraseIndex < phraseWords.length; phraseIndex++) {
        if (startWord === phraseWords[phraseIndex]) {
          // ‰ªéËøô‰∏™‰ΩçÁΩÆÂºÄÂßãÂ∞ùËØïÂåπÈÖçÂâ©‰ΩôÈÉ®ÂàÜ
          const matchedWords: number[] = [searchStart];
          let currentPhraseIndex = phraseIndex + 1;
          let currentSearchIndex = searchStart + 1;
          let skippedNonEmpty = 0;
          
          while (currentPhraseIndex < phraseWords.length && currentSearchIndex < rubyWords.length) {
            const targetWord = phraseWords[currentPhraseIndex]!;
            const searchWord = rubyWords[currentSearchIndex];
            
            if (!searchWord || searchWord.length === 0) {
              currentSearchIndex++;
              continue;
            }
            
            if (searchWord === targetWord) {
              matchedWords.push(currentSearchIndex);
              currentPhraseIndex++;
              currentSearchIndex++;
              skippedNonEmpty = 0;
            } else {
              currentSearchIndex++;
              skippedNonEmpty++;
              
              if (skippedNonEmpty > 3) {
                break;
              }
            }
          }
          
          // ËÆ°ÁÆóÊÄªÂåπÈÖçÊï∞ÔºàÂåÖÊã¨‰πãÂâçÂåπÈÖçÁöÑ‰∏Ä‰∏™ËØçÔºâ
          const totalMatched = 1 + (currentPhraseIndex - phraseIndex - 1);
          const matchRatio = totalMatched / phraseWords.length;
          
          if (matchRatio >= 0.7 && totalMatched >= 2 && matchedWords.length >= 2) {
            const startIndex = matchedWords[0]!;
            const endIndex = matchedWords[matchedWords.length - 1]!;
            
            if (!bestMatch || totalMatched > bestMatch.matchedCount) {
              bestMatch = { startIndex, endIndex, matchedCount: totalMatched };
            }
          }
          
          break; // Âè™Â∞ùËØïÁ¨¨‰∏Ä‰∏™ÂåπÈÖçÁöÑÂêéÁª≠ÂçïËØç
        }
      }
    }
    
    if (bestMatch) {
      return { startIndex: bestMatch.startIndex, endIndex: bestMatch.endIndex };
    }
    
    return null;
  }, []);

  // ÂàõÂª∫Âü∫‰∫éÁ¥¢ÂºïÁöÑËØçÁªÑÂíå‰∏ìÊúâÂêçËØçÊ≥®Èáä
  const createIndexBasedPhraseAnnotations = useCallback((htmlText: string, annotations: { mwes: MWEAnnotation[], proper_nouns: ProperNounAnnotation[] }): string => {
    // È¶ñÂÖàÊèêÂèñrubyÂçïËØçÊï∞ÁªÑ
    const rubyWords = extractRubyWordsArray(htmlText);
    
    if (rubyWords.length === 0) {
      return htmlText;
    }
    
    // ÂêàÂπ∂Â§ÑÁêÜËØçÁªÑÂíå‰∏ìÊúâÂêçËØçÔºåÊåâÈïøÂ∫¶ÈôçÂ∫èÂ§ÑÁêÜ
    const allPhrases = [
      ...annotations.mwes.map(mwe => ({ ...mwe, type: 'mwe' as const, text: mwe.phrase })),
      ...annotations.proper_nouns.map(pn => ({ ...pn, type: 'proper_noun' as const, text: pn.phrase }))
    ]
      .filter(item => item.text && item.text.trim())
      .sort((a, b) => b.text.length - a.text.length);

    let resultHTML = htmlText;
    const processedRanges = new Set<string>(); // ËÆ∞ÂΩïÂ∑≤Â§ÑÁêÜÁöÑÁ¥¢ÂºïËåÉÂõ¥
    let processedCount = 0;

    for (const item of allPhrases) {
      const phrase = item.text.trim();
      
      // ‰ΩøÁî®Á¥¢ÂºïÂåπÈÖçÊü•ÊâæËØçÁªÑ
      const match = matchPhraseWithIndexes(rubyWords, phrase);
      
      if (!match) {
        continue;
      }
      
      const { startIndex, endIndex } = match;
      const rangeKey = `${startIndex}-${endIndex}`;
      
      // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÂ§ÑÁêÜËøáËøô‰∏™ËåÉÂõ¥
      if (processedRanges.has(rangeKey)) {
        continue;
      }
      
      // Ê†áËÆ∞Ëøô‰∏™ËåÉÂõ¥‰∏∫Â∑≤Â§ÑÁêÜ
      processedRanges.add(rangeKey);
      
      // ÊâæÂà∞ÂØπÂ∫îÁöÑrubyÊ†áÁ≠æËåÉÂõ¥
      const startPattern = new RegExp(`<ruby[^>]*data-word-index="${startIndex}"[^>]*>`, 'g');
      
      const startMatch = startPattern.exec(resultHTML);
      
      if (!startMatch) {
        continue;
      }
      
      // ÊâæÂà∞ÁªìÊùü‰ΩçÁΩÆÔºàÁ¨¨endIndex‰∏™rubyÊ†áÁ≠æÁöÑÁªìÊùüÔºâ
      let endMatch: RegExpMatchArray | null = null;
      const searchPos = startMatch.index;
      
      // ÈáçÁΩÆÊ≠£ÂàôË°®ËææÂºèÁöÑlastIndex
      const rubyEndPattern = new RegExp(`<ruby[^>]*data-word-index="(\\d+)"[^>]*>.*?</ruby>`, 'g');
      rubyEndPattern.lastIndex = searchPos;
      
      let rubyMatch;
      while ((rubyMatch = rubyEndPattern.exec(resultHTML)) !== null) {
        const currentIndex = parseInt(rubyMatch[1]!, 10);
        
        if (currentIndex === endIndex) {
          endMatch = rubyMatch;
          break;
        }
      }
      
      if (!endMatch) {
        continue;
      }
      
      const startPos = startMatch.index;
      const endPos = endMatch.index! + endMatch[0].length;
      const matchedText = resultHTML.substring(startPos, endPos);
      
      // ÁîüÊàêspanÊ†áÁ≠æ
      let spanTag: string;
      
      if (item.type === 'proper_noun') {
        const enAnnotation = item.en || 'Unknown';
        const zhAnnotation = item.zh || 'Êú™Áü•';
        spanTag = `<span class="PROPN">${matchedText}<span class="annotation en">(${enAnnotation})</span><span class="annotation zh">(${zhAnnotation})</span></span>`;
      } else {
        // MWEÁ±ªÂûã
        const enAnnotation = item.en || 'Multi-word expression';
        const zhAnnotation = item.zh || 'Â§öËØçË°®Ëææ';
        spanTag = `<span class="mwe">${matchedText}<span class="annotation en">(${enAnnotation})</span><span class="annotation zh">(${zhAnnotation})</span></span>`;
      }
      
      // ÊõøÊç¢
      resultHTML = resultHTML.slice(0, startPos) + spanTag + resultHTML.slice(endPos);
      processedCount++;
    }

    console.log(`ÔøΩÔ∏è Phrase matching completed: ${processedCount}/${allPhrases.length} phrases matched`);
    return resultHTML;
  }, [extractRubyWordsArray, matchPhraseWithIndexes]);

  // Â∏¶ÈáçËØïÊú∫Âà∂ÁöÑÂçïËØçÊ≥®ÈáäÂ§ÑÁêÜÔºàÁ¨¨‰∏ÄÊ≠•ÔºöÂè™Ëé∑ÂèñÂçïËØçÔºâ
  const annotateWordsWithRetry = useCallback(async (text: string, attempts = 0): Promise<{ words: WordAnnotation[], usage?: TokenUsage } | null> => {
    try {
      const annotationProvider = getAnnotationProvider(provider);
      if (!annotationProvider) {
        throw new Error(`Annotation provider '${provider}' not found`);
      }

      console.log('‚ù§Ô∏è Calling LLM for words:', text.substring(0, 50));
      const result = await annotationProvider.annotate(`words:${text}`);
      
      // ÊâìÂç∞ LLM ËøîÂõûÁöÑ JSON ÂÜÖÂÆπ
      console.log('üî§ LLM Words Response JSON:', JSON.stringify(result, null, 2));
      
      return { words: result.words || [], usage: result.usage };
    } catch (error) {
      console.error(`Words annotation attempt ${attempts + 1} failed:`, error);
      
      if (attempts < retryAttempts) {
        const delay = retryDelay * Math.pow(2, attempts);
        await new Promise(resolve => setTimeout(resolve, delay));
        return annotateWordsWithRetry(text, attempts + 1);
      }
      
      return { words: [] };
    }
  }, [provider, retryAttempts, retryDelay]);

  // Â∏¶ÈáçËØïÊú∫Âà∂ÁöÑËØçÁªÑÂíå‰∏ìÊúâÂêçËØçÊ≥®ÈáäÂ§ÑÁêÜÔºàÁ¨¨‰∫åÊ≠•ÔºöËé∑ÂèñËØçÁªÑÂíåÂ§öËØç‰∏ìÊúâÂêçËØçÔºâ
  const annotatePhrasesAndProperNounsWithRetry = useCallback(async (text: string, attempts = 0): Promise<{ mwes: MWEAnnotation[], proper_nouns: ProperNounAnnotation[], usage?: TokenUsage } | null> => {
    try {
      const annotationProvider = getAnnotationProvider(provider);
      if (!annotationProvider) {
        throw new Error(`Annotation provider '${provider}' not found`);
      }

      console.log('üè∑Ô∏è Calling LLM for phrases and proper nouns:', text.substring(0, 50));
      const result = await annotationProvider.annotate(`phrases:${text}`);
      
      // ÊâìÂç∞ LLM ËøîÂõûÁöÑ JSON ÂÜÖÂÆπ
      console.log('üè∑Ô∏è LLM Phrases Response JSON:', JSON.stringify(result, null, 2));
      
      return { mwes: result.mwes || [], proper_nouns: result.proper_nouns || [], usage: result.usage };
    } catch (error) {
      console.error(`Phrases annotation attempt ${attempts + 1} failed:`, error);
      
      if (attempts < retryAttempts) {
        const delay = retryDelay * Math.pow(2, attempts);
        await new Promise(resolve => setTimeout(resolve, delay));
        return annotatePhrasesAndProperNounsWithRetry(text, attempts + 1);
      }
      
      return { mwes: [], proper_nouns: [] };
    }
  }, [provider, retryAttempts, retryDelay]);

  // Ê≥®ÈáäÂçï‰∏™ÂÖÉÁ¥†ÔºàÁ±ª‰ººtranslationÁöÑtranslateElementÔºâ
  const annotateElement = useCallback(async (el: HTMLElement) => {
    if (!enabledRef.current) return;
    
    // ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÊ≠£Á°ÆÂ§ÑÁêÜÊç¢Ë°åÁ¨¶ÔºåÂ∞Ü\nÊõøÊç¢‰∏∫Á©∫Ê†ºËÄå‰∏çÊòØÁõ¥Êé•Âà†Èô§
    const text = el.textContent?.replace(/\n/g, ' ').trim();
    if (!text || text.length < 3) return;

    // Ë∑≥ËøáÂ∑≤Ê≥®ÈáäÁöÑÂÖÉÁ¥†
    if (isElementAnnotated(el)) return;

    // Ë∑≥ËøáÁâπÂÆöÁ±ªÂûãÁöÑÂÖÉÁ¥†
    if (el.classList.contains('annotation-target') || 
        ['pre', 'code', 'math', 'ruby', 'style', 'script'].includes(el.tagName.toLowerCase())) {
      return;
    }

    // ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÊ£ÄÊü•ÊòØÂê¶ÊúâÊú™ÂÆåÊàêÁöÑÊ≥®Èáä‰ªªÂä° - ‰∏•Ê†ºÁ≠âÂæÖ‰πãÂâçÁöÑËäÇÁÇπÂ§ÑÁêÜÂÆåÊàê
    const currentlyProcessing = document.querySelectorAll('.processing-annotation');
    if (currentlyProcessing.length > 0) {
      console.log(`‚è≥ Waiting for ${currentlyProcessing.length} nodes to finish processing before starting new annotation`);
      
      // Á≠âÂæÖÊõ¥ÈïøÊó∂Èó¥Âπ∂ÈÄíÂΩíÈáçËØïÔºåÁ°Æ‰øùÂÆåÂÖ®ÂÆåÊàêÂâç‰∏çÂºÄÂßãÊñ∞ÁöÑÊ≥®Èáä
      setTimeout(() => {
        annotateElement(el);
      }, 2000);
      return;
    }

    // ÈÅøÂÖçÈáçÂ§çÂ§ÑÁêÜ
    if (processingQueue.current.has(el)) {
      console.log(`‚ö†Ô∏è Element already in processing queue, skipping`);
      return;
    }
    
    processingQueue.current.add(el);

    // Ê∑ªÂä†Â§ÑÁêÜ‰∏≠Ê†áËÆ∞
    el.classList.add('processing-annotation');
    console.log(`üöÄ Starting annotation for element: "${text.substring(0, 50)}..."`);
    console.log(`üìä Current processing queue size: ${processingQueue.current.size}`);

    try {
      // ‰øùÂ≠òÂéüÂßãÊñáÊú¨ËäÇÁÇπÔºàÁ±ª‰ººtranslationÁöÑupdateSourceNodesÈÄªËæëÔºâ
      const hasDirectText = Array.from(el.childNodes).some(
        (node) => node.nodeType === Node.TEXT_NODE && node.textContent?.trim() !== ''
      );
      
      if (hasDirectText && !el.hasAttribute('original-text-stored')) {
        const textNodes = Array.from(el.childNodes).filter(
          (node) => node.nodeType === Node.TEXT_NODE && node.textContent?.trim() !== ''
        );
        
        el.setAttribute(
          'original-text-nodes',
          JSON.stringify(textNodes.map((node) => node.textContent))
        );
        el.setAttribute('original-text-stored', 'true');
      }

      // Á¨¨‰∏ÄÊ≠•ÔºöËé∑ÂèñÂçïËØçÊ≥®ÈáäÔºàÂü∫‰∫éÁ∫ØÊñáÊú¨ÔºåÊåâÈ°∫Â∫èÔºâ
      console.log(`üî§ Requesting word annotations for: "${text}"`);
      const wordsAnnotations = await annotateWordsWithRetry(text);
      
      // Á¨¨‰∫åÊ≠•ÔºöËé∑ÂèñËØçÁªÑÂíåÂ§öËØç‰∏ìÊúâÂêçËØçÁöÑÊ≥®ÈáäÔºàÂü∫‰∫éÂêåÊ†∑ÁöÑÁ∫ØÊñáÊú¨Ôºâ
      console.log(`üè∑Ô∏è Requesting phrase annotations for: "${text}"`);
      const phrasesAnnotations = await annotatePhrasesAndProperNounsWithRetry(text);
      
      // Á¨¨‰∏âÊ≠•ÔºöÂÖàÂ§ÑÁêÜÂçïËØçÔºåÂàõÂª∫rubyÊ†áÁ≠æÔºà‰ΩøÁî®Êñ∞ÁöÑÈ°∫Â∫èÂåπÈÖçÁÆóÊ≥ïÔºâ
      let processedHTML = text;
      if (wordsAnnotations && wordsAnnotations.words.length > 0 && enabledRef.current) {
        console.log(`üî§ Processing ${wordsAnnotations.words.length} word annotations`);
        processedHTML = createOrderedWordRubyAnnotations(text, wordsAnnotations);
        console.log('After word annotations:', processedHTML.substring(0, 200));
      }

      // Á¨¨ÂõõÊ≠•ÔºöÂú®rubyÊ†áÁ≠æÂü∫Á°Ä‰∏äÊ∑ªÂä†ËØçÁªÑÂíå‰∏ìÊúâÂêçËØçspanÂåÖË£Ö
      if (phrasesAnnotations && (phrasesAnnotations.mwes.length > 0 || phrasesAnnotations.proper_nouns.length > 0) && 
          enabledRef.current && (viewSettings?.phraseAnnotationEnabled || viewSettings?.wordAnnotationEnabled)) {
        console.log(`üè∑Ô∏è Processing ${phrasesAnnotations.mwes.length} MWEs and ${phrasesAnnotations.proper_nouns.length} proper nouns`);
        console.log('üîç About to call createIndexBasedPhraseAnnotations');
        processedHTML = createIndexBasedPhraseAnnotations(processedHTML, phrasesAnnotations);
        console.log('üîç After phrase and proper noun annotations:', processedHTML.substring(0, 200));
      }

      // Á¨¨‰∫îÊ≠•ÔºöÊõ¥Êñ∞ÂÖÉÁ¥†ÂÜÖÂÆπÔºàÂè™ÊúâÂú®ÂÜÖÂÆπÂèëÁîüÂèòÂåñÊó∂ÊâçÊõ¥Êñ∞Ôºâ
      if (enabledRef.current && processedHTML !== text) {
        el.innerHTML = processedHTML;
        el.setAttribute('word-annotation-mark', '1');
        
        // Ê†áËÆ∞‰∏∫Â∑≤Ê≥®Èáä
        if (!annotatedElements.current.includes(el)) {
          annotatedElements.current.push(el);
        }
        
        // Ê∑ªÂä†ÂÆåÊàêÊ†áËÆ∞ÔºåÁßªÈô§Â§ÑÁêÜ‰∏≠Ê†áËÆ∞
        el.classList.add('annotated');
        el.classList.remove('processing-annotation');
        
        // Ëß¶ÂèëÊ≥®ÈáäÂºÄÂßã‰∫ã‰ª∂
        window.dispatchEvent(new CustomEvent('annotation-start'));
        console.log(`‚úÖ Annotation completed for element: "${text.substring(0, 50)}..."`);
        console.log('Final HTML set for element:', processedHTML.substring(0, 200));
        
        // Êñ∞Â¢ûÔºöÂçï‰∏™ËäÇÁÇπÊ≥®ÈáäÂÆåÊàêÂêéÁ´ãÂç≥Ëß¶ÂèëÁä∂ÊÄÅÊõ¥Êñ∞
        triggerStatusUpdate();
      } else {
        console.log('No annotations found or content unchanged, skipping HTML update');
        // Âç≥‰ΩøÊ≤°ÊúâÊ≥®ÈáäÔºå‰πüË¶ÅÊ†áËÆ∞‰∏∫Â∑≤Â§ÑÁêÜ
        el.classList.add('annotated');
        el.classList.remove('processing-annotation');
        
        // Êñ∞Â¢ûÔºöÂç≥‰ΩøÊ≤°ÊúâÊ≥®ÈáäÂèòÂåñÔºå‰πüËß¶ÂèëÁä∂ÊÄÅÊõ¥Êñ∞‰ª•Á°Æ‰øùCSSÂàÜÁ±ªÊ≠£Á°Æ
        triggerStatusUpdate();
      }
    } catch (error) {
      console.error('Failed to annotate element:', error);
      // Âá∫ÈîôÊó∂‰πüË¶ÅÁßªÈô§Â§ÑÁêÜ‰∏≠Ê†áËÆ∞
      el.classList.remove('processing-annotation');
      window.dispatchEvent(new CustomEvent('annotation-error', {
        detail: { error }
      }));
    } finally {
      // ‰ªéÂ§ÑÁêÜÈòüÂàó‰∏≠ÁßªÈô§
      processingQueue.current.delete(el);
      console.log(`üèÅ Element processing completed. Queue size: ${processingQueue.current.size}`);
      
      // Ê£ÄÊü•ÊòØÂê¶ÊâÄÊúâÂ§ÑÁêÜÈÉΩÂÆåÊàê
      if (processingQueue.current.size === 0) {
        console.log(`üéâ All annotation tasks completed!`);
        window.dispatchEvent(new CustomEvent('annotation-end'));
      }
    }
  }, [enabledRef, isElementAnnotated, annotateWordsWithRetry, annotatePhrasesAndProperNounsWithRetry, createOrderedWordRubyAnnotations, createIndexBasedPhraseAnnotations, viewSettings?.phraseAnnotationEnabled, viewSettings?.wordAnnotationEnabled]);

  // Âú®ËåÉÂõ¥ÂÜÖÊ≥®ÈáäÔºàÁ±ª‰ººtranslationÁöÑtranslateInRangeÔºâ
  const annotateInRange = useCallback(
    debounce((range: Range) => {
      const nodes = allTextNodes.current;
      if (nodes.length === 0) return;
      
      // ÊâæÂà∞ËåÉÂõ¥ÂÜÖÁöÑËäÇÁÇπ
      const startContainer = range.startContainer;
      const endContainer = range.endContainer;
      
      let startIndex = -1;
      let endIndex = -1;
      
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i]!;
        if (node === startContainer || node.contains(startContainer)) {
          if (startIndex === -1) startIndex = i;
        }
        if (node === endContainer || node.contains(endContainer)) {
          endIndex = i;
        }
      }
      
      if (startIndex === -1) return;
      if (endIndex === -1) endIndex = startIndex;
      
      const beforeStart = Math.max(0, startIndex - 2);
      const afterEnd = Math.min(nodes.length - 1, endIndex + 2);
      
      for (let i = beforeStart; i <= afterEnd; i++) {
        const node = nodes[i];
        if (node) {
          annotateElement(node);
        }
      }
    }, 500),
    [annotateElement]
  );

  // ÁõëÂê¨TTSËøõÂ∫¶ÂèòÂåñÔºàÁ±ª‰ººtranslationÁöÑTTSÁõëÂê¨Ôºâ
  useEffect(() => {
    if (viewState?.ttsEnabled && progress && document.hidden) {
      const { range } = progress;
      annotateInRange(range);
    }
  }, [viewState?.ttsEnabled, progress, annotateInRange]);

  // ÂìçÂ∫îËÆæÁΩÆÂèòÂåñ
  useEffect(() => {
    if (!viewSettings) return;

    const enabledChanged = enabledRef.current !== (viewSettings.wordAnnotationEnabled && enabled);

    if (enabledChanged) {
      enabledRef.current = viewSettings.wordAnnotationEnabled && enabled;
    }

    if (enabledChanged) {
      toggleAnnotationVisibility(!!enabledRef.current);
      if (enabledRef.current) {
        observeTextNodes();
      }
    }
  }, [bookKey, viewSettings, enabled, provider, toggleAnnotationVisibility, observeTextNodes, updateAnnotation]);

  // ÁõëÂê¨viewÂèòÂåñ
  useEffect(() => {
    if (!view || !enabledRef.current) return;

    if ('renderer' in view) {
      view.addEventListener('load', observeTextNodes);
    } else {
        console.log('üìå Direct view detected, observing text nodes immediately');
      observeTextNodes();
    }

    return () => {
      if ('renderer' in view) {
        view.removeEventListener('load', observeTextNodes);
      }
      observerRef.current?.disconnect();
      annotatedElements.current = [];
    };
  }, [view, observeTextNodes]);

  return {
    annotateElement,
    toggleAnnotationVisibility,
    isAnnotating: processingQueue.current.size > 0,
    registerStatusUpdateCallback, // Êñ∞Â¢ûÔºöÂØºÂá∫Áä∂ÊÄÅÊõ¥Êñ∞ÂõûË∞ÉÊ≥®ÂÜåÂáΩÊï∞
  };
}
